<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<title>Module eipmi</title>
<link rel="stylesheet" type="text/css" href="stylesheet.css" title="EDoc">
</head>
<body bgcolor="white">
<div class="navbar"><a name="#navbar_top"></a><table width="100%" border="0" cellspacing="0" cellpadding="2" summary="navigation bar"><tr><td><a href="overview-summary.html" target="overviewFrame">Overview</a></td><td><a href="http://www.erlang.org/"><img src="erlang.png" align="right" border="0" alt="erlang logo"></a></td></tr></table></div>
<hr>

<h1>Module eipmi</h1>
<ul class="index"><li><a href="#description">Description</a></li><li><a href="#types">Data Types</a></li><li><a href="#index">Function Index</a></li><li><a href="#functions">Function Details</a></li></ul>
   The main entry module of the <code>eipmi</code> application containing the application   
callback as well as the top level supervisor.

<p><b>Behaviours:</b> <a href="application.html"><tt>application</tt></a>, <a href="supervisor.html"><tt>supervisor</tt></a>.</p>

<h2><a name="description">Description</a></h2><p>
   The main entry module of the <code>eipmi</code> application containing the application   
callback as well as the top level supervisor.</p>
  
   This module provides capabilities to discover and use IPMI-capable devices.
   The <a href="eipmi_session.html"><code>eipmi_session</code></a> module provides a IPMI session implementation that
   is able to send requests and receive responses implemented in the
   <a href="eipmi_request.html"><code>eipmi_request</code></a> and <a href="eipmi_response.html"><code>eipmi_response</code></a> modules. Frontend API
   functions using a combination of several requests to provide a certain
   feature should be put here.
<h2><a name="types">Data Types</a></h2>

<h3 class="typedecl"><a name="type-option">option()</a></h3>
<p><tt>option() = {initial_outbound_seq_nr, non_neg_integer()} | {password, string()} | {port, <a href="inet.html#type-port_number">inet:port_number()</a>} | {privilege, callback | user | operator | administrator} | {rq_addr, 129..141} | {timeout, non_neg_integer()} | {user, string()}</tt></p>


<h3 class="typedecl"><a name="type-option_name">option_name()</a></h3>
<p><tt>option_name() = initial_outbound_seq_nr | password | port | privilege | rq_addr | timeout | user</tt></p>


<h3 class="typedecl"><a name="type-req_net_fn">req_net_fn()</a></h3>
<p><tt>req_net_fn() = 4 | 6 | 10 | 12</tt></p>


<h3 class="typedecl"><a name="type-request">request()</a></h3>
<p><tt>request() = {<a href="#type-req_net_fn">req_net_fn()</a>, Command::0..255}</tt></p>


<h3 class="typedecl"><a name="type-resp_net_fn">resp_net_fn()</a></h3>
<p><tt>resp_net_fn() = 5 | 7 | 11 | 13</tt></p>


<h3 class="typedecl"><a name="type-response">response()</a></h3>
<p><tt>response() = {<a href="#type-resp_net_fn">resp_net_fn()</a>, Command::0..255}</tt></p>


<h3 class="typedecl"><a name="type-session">session()</a></h3>
<p><b>abstract datatype</b>: <tt>session()</tt></p>


<h3 class="typedecl"><a name="type-target">target()</a></h3>
<p><tt>target() = {<a href="inet.html#type-ip_address">inet:ip_address()</a> | <a href="inet.html#type-hostname">inet:hostname()</a>, <a href="inet.html#type-port_number">inet:port_number()</a>}</tt></p>


<h2><a name="index">Function Index</a></h2>
<table width="100%" border="1" cellspacing="0" cellpadding="2" summary="function index"><tr><td valign="top"><a href="#close-1">close/1</a></td><td>
  Closes an IPMI session previously opened with <a href="#open-1"><code>open/1</code></a> or
  <a href="#open-2"><code>open/2</code></a>.</td></tr>
<tr><td valign="top"><a href="#open-1">open/1</a></td><td>
  Opens an IPMI session to a given host.</td></tr>
<tr><td valign="top"><a href="#open-2">open/2</a></td><td>
  Same as <a href="#open-1"><code>open/1</code></a> but allows the specification of the following custom
  options:
  <dl>
    <dt><code>{initial_outbound_seq_nr, non_neg_integer()}</code></dt>
    <dd>
      <p>
      the initial outbound sequence number that will be requested on the BMC,
      default is <code>16#1337</code>
      </p>
   </dd>
    <dt><code>{password, string() with length &lt;= 16bytes}</code></dt>
    <dd>
      <p>
      a password string used for authentication when anonymous login is not
      available, default is <code>""</code>
      </p>
    </dd>
    <dt><code>{port, inet:port_number()}</code></dt>
    <dd>
      <p>
      the RMCP port the far end is expecting incoming RMCP and IPMI packets,
      default is <code>623</code>
      </p>
    </dd>
    <dt><code>{privilege, callback | user | operator | administrator}</code></dt>
    <dd>
      <p>
      the requested privilege level for this session, default is
      <code>administrator</code>
      </p>
    </dd>
    <dt><code>{rq_addr, 16#81..16#8d}</code></dt>
    <dd>
      <p>
      the requestor address used in IPMI lan packages, the default value of
      <code>16#81</code> should be suitable for all common cases
      </p>
    </dd>
    <dt><code>{timeout, non_neg_integer()}</code></dt>
    <dd>
      <p>
      the timeout for IPMI requests, default is <code>1000ms</code>
      </p>
    </dd>
    <dt><code>{user, string() with length &lt;= 16bytes}</code></dt>
    <dd>
      <p>
      a user name string used for authentication when neither anonymous nor
      null user login are available, default is <code>""</code>
      </p>
    </dd>
  </dl></td></tr>
<tr><td valign="top"><a href="#ping-1">ping/1</a></td><td>
  Pings a given host using RMCP ping.</td></tr>
<tr><td valign="top"><a href="#ping-2">ping/2</a></td><td>
  Same as <a href="#ping-1"><code>ping/1</code></a> but allows the specification of a custom receive
  timeout value in milliseconds.</td></tr>
<tr><td valign="top"><a href="#raw-4">raw/4</a></td><td>
  Sends a raw IPMI command over a given session.</td></tr>
<tr><td valign="top"><a href="#read_fru-2">read_fru/2</a></td><td>
  Return the FRU inventory data for a specific FRU id.</td></tr>
<tr><td valign="top"><a href="#read_sel-2">read_sel/2</a></td><td>
  Return all currently available entries from the System Event Log (SEL).</td></tr>
<tr><td valign="top"><a href="#stats-0">stats/0</a></td><td>
  Returns statistical information about the currently opened sessions and the
  registered event handlers.</td></tr>
<tr><td valign="top"><a href="#subscribe-2">subscribe/2</a></td><td>
  Registers/adds a handler for session related events.</td></tr>
<tr><td valign="top"><a href="#unsubscribe-2">unsubscribe/2</a></td><td>
  Unregisters/removes a handler for session related events previously added
  using <a href="#subscribe-2"><code>subscribe/2</code></a>.</td></tr>
</table>

<h2><a name="functions">Function Details</a></h2>

<h3 class="function"><a name="close-1">close/1</a></h3>
<div class="spec">
<p><tt>close(Session::<a href="#type-session">session()</a>) -&gt; ok | {error, no_session}</tt><br></p>
</div><p>
  Closes an IPMI session previously opened with <a href="#open-1"><code>open/1</code></a> or
  <a href="#open-2"><code>open/2</code></a>. This will return <code>{error, no_session}</code> when the given
  session is not active any more.</p>

<h3 class="function"><a name="open-1">open/1</a></h3>
<div class="spec">
<p><tt>open(IPAddress::<a href="inet.html#type-ip_address">inet:ip_address()</a> | <a href="inet.html#type-hostname">inet:hostname()</a>) -&gt; {ok, <a href="#type-session">session()</a>} | {error, term()}</tt><br></p>
</div><p><p>
  Opens an IPMI session to a given host. With default parameters. Please note
  that this will only work for IPMI targets supporting anonymous login. For all
  other login types at least the <code>password</code> and maybe the <code>user</code> option will be  
required.</p>
 
  The returned handle can be used to send requests to the target BMC using one
  of the functions provided by this module (e.g. <a href="#raw-4"><code>raw/4</code></a>) or close the
  session using <a href="#close-1"><code>close/1</code></a>.</p>
<p><b>See also:</b> <a href="#close-1">close/1</a>, <a href="#open-2">open/2</a>.</p>

<h3 class="function"><a name="open-2">open/2</a></h3>
<div class="spec">
<p><tt>open(IPAddress::<a href="inet.html#type-ip_address">inet:ip_address()</a> | <a href="inet.html#type-hostname">inet:hostname()</a>, Options::[<a href="#type-option">option()</a>]) -&gt; {ok, <a href="#type-session">session()</a>} | {error, term()}</tt><br></p>
</div><p>
  Same as <a href="#open-1"><code>open/1</code></a> but allows the specification of the following custom
  options:
  <dl>
    <dt><code>{initial_outbound_seq_nr, non_neg_integer()}</code></dt>
    <dd>
      <p>
      the initial outbound sequence number that will be requested on the BMC,
      default is <code>16#1337</code>
      </p>
   </dd>
    <dt><code>{password, string() with length &lt;= 16bytes}</code></dt>
    <dd>
      <p>
      a password string used for authentication when anonymous login is not
      available, default is <code>""</code>
      </p>
    </dd>
    <dt><code>{port, inet:port_number()}</code></dt>
    <dd>
      <p>
      the RMCP port the far end is expecting incoming RMCP and IPMI packets,
      default is <code>623</code>
      </p>
    </dd>
    <dt><code>{privilege, callback | user | operator | administrator}</code></dt>
    <dd>
      <p>
      the requested privilege level for this session, default is
      <code>administrator</code>
      </p>
    </dd>
    <dt><code>{rq_addr, 16#81..16#8d}</code></dt>
    <dd>
      <p>
      the requestor address used in IPMI lan packages, the default value of
      <code>16#81</code> should be suitable for all common cases
      </p>
    </dd>
    <dt><code>{timeout, non_neg_integer()}</code></dt>
    <dd>
      <p>
      the timeout for IPMI requests, default is <code>1000ms</code>
      </p>
    </dd>
    <dt><code>{user, string() with length &lt;= 16bytes}</code></dt>
    <dd>
      <p>
      a user name string used for authentication when neither anonymous nor
      null user login are available, default is <code>""</code>
      </p>
    </dd>
  </dl></p>

<h3 class="function"><a name="ping-1">ping/1</a></h3>
<div class="spec">
<p><tt>ping(IPAddress::<a href="inet.html#type-ip_address">inet:ip_address()</a> | <a href="inet.html#type-hostname">inet:hostname()</a>) -&gt; pang | pong</tt><br></p>
</div><p>
  Pings a given host using RMCP ping. This can be done to check a device for
  the IPMI capability before opening a session to it. Default receive timeout
  is 5000 milliseconds. Returns <code>pong</code> if the pinged host supports IPMI,
  <code>pang</code> otherwise.</p>
<p><b>See also:</b> <a href="#ping-2">ping/2</a>.</p>

<h3 class="function"><a name="ping-2">ping/2</a></h3>
<div class="spec">
<p><tt>ping(IPAddress::<a href="inet.html#type-ip_address">inet:ip_address()</a> | <a href="inet.html#type-hostname">inet:hostname()</a>, Timeout::timeout()) -&gt; pang | pong</tt><br></p>
</div><p>
  Same as <a href="#ping-1"><code>ping/1</code></a> but allows the specification of a custom receive
  timeout value in milliseconds.</p>

<h3 class="function"><a name="raw-4">raw/4</a></h3>
<div class="spec">
<p><tt>raw(Session::<a href="#type-session">session()</a>, NetFn::<a href="#type-req_net_fn">req_net_fn()</a>, Command::0..255, Properties::<a href="proplists.html#type-proplist">proplists:proplist()</a>) -&gt; {ok, <a href="proplists.html#type-proplist">proplists:proplist()</a>} | {error, term()}</tt><br></p>
</div><p>
  Sends a raw IPMI command over a given session. DO NOT USE THIS unless you
  really know what you're doing!</p>

<h3 class="function"><a name="read_fru-2">read_fru/2</a></h3>
<div class="spec">
<p><tt>read_fru(Session::<a href="#type-session">session()</a>, FruId::0..254) -&gt; {ok, <a href="eipmi_fru.html#type-info">eipmi_fru:info()</a>} | {error, term()}</tt><br></p>
</div><p>
  Return the FRU inventory data for a specific FRU id. The returned FRU
  information is a property list that does only contain the available and
  checksum error free fields of the inventory. If no FRU data is available for
  a specific id the returned inventory data is the empty list.</p>

<h3 class="function"><a name="read_sel-2">read_sel/2</a></h3>
<div class="spec">
<p><tt>read_sel(Session::<a href="#type-session">session()</a>, Clear::boolean()) -&gt; {ok, [<a href="eipmi_sel.html#type-entry">eipmi_sel:entry()</a>]} | {error, term()}</tt><br></p>
</div><p>
  Return all currently available entries from the System Event Log (SEL). The
  returned SEL entries are property lists that do only contain the available
  and checksum error free fields of the respective entry. Using the second
  argument the SEL can optionally be cleared after reading.
  TODO</p>

<h3 class="function"><a name="stats-0">stats/0</a></h3>
<div class="spec">
<p><tt>stats() -&gt; [{sessions, [{<a href="#type-target">target()</a>, pid()}]} | {handlers, [module() | {module(), term()}]}]</tt><br></p>
</div><p>
  Returns statistical information about the currently opened sessions and the
  registered event handlers.</p>

<h3 class="function"><a name="subscribe-2">subscribe/2</a></h3>
<div class="spec">
<p><tt>subscribe(Handler::module() | {module(), term()}, Args::term()) -&gt; ok | {error, term()}</tt><br></p>
</div><p>
  Registers/adds a handler for session related events. The handler module must
  implement the <a href="gen_event.html"><code>gen_event</code></a> behaviour. For more information on the
  arguments <code>Handler</code> and <code>Args</code> refer to <a href="gen_event.html#add_handler-3"><code>gen_event:add_handler/3</code></a>.
  The event handling module should be prepared to receive the following events
  on the <code>handle_call/2</code> callback:
  <dl>
    <dt><code>{Session :: session(), established}</code></dt>
    <dd>
      <p>the session was successfully established and activated</p>
    </dd>
    <dt><code>{Session :: session(), {closed, Reason :: term()}}</code></dt>
    <dd>
      <p>the session was closed with the provided reason</p>
    </dd>
    <dt><code>{Session :: session(), {decode_error, Reason :: term()}}</code></dt>
    <dd>
      <p>a received packet could not be decoded</p>
    </dd>
    <dt><code>{Session :: session(), {request_timeout,
                                 RqSeqNr :: non_neg_integer()}}</code></dt>
    <dd>
      <p>the corresponding request timed out</p>
    </dd>
    <dt><code>{Session :: session(), {no_requestor, {RqSeqNr :: non_neg_integer(),
                                                Response}}}</code></dt>
    <dd>
      <p>no requestor could be found for the corresponding request</p>
    </dd>
  </dl></p>

<h3 class="function"><a name="unsubscribe-2">unsubscribe/2</a></h3>
<div class="spec">
<p><tt>unsubscribe(Handler::module() | {module(), term()}, Args::term()) -&gt; term()</tt><br></p>
</div><p>
  Unregisters/removes a handler for session related events previously added
  using <a href="#subscribe-2"><code>subscribe/2</code></a>. For more information refer to on the arguments
  <a href="gen_event.html#delete_handler-3"><code>gen_event:delete_handler/3</code></a>.</p>
<hr>

<div class="navbar"><a name="#navbar_bottom"></a><table width="100%" border="0" cellspacing="0" cellpadding="2" summary="navigation bar"><tr><td><a href="overview-summary.html" target="overviewFrame">Overview</a></td><td><a href="http://www.erlang.org/"><img src="erlang.png" align="right" border="0" alt="erlang logo"></a></td></tr></table></div>
<p><i>Generated by EDoc, Nov 12 2012, 15:55:49.</i></p>
</body>
</html>
