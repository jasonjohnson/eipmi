<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<title>Module eipmi_session</title>
<link rel="stylesheet" type="text/css" href="stylesheet.css" title="EDoc">
</head>
<body bgcolor="white">
<div class="navbar"><a name="#navbar_top"></a><table width="100%" border="0" cellspacing="0" cellpadding="2" summary="navigation bar"><tr><td><a href="overview-summary.html" target="overviewFrame">Overview</a></td><td><a href="http://www.erlang.org/"><img src="erlang.png" align="right" border="0" alt="erlang logo"></a></td></tr></table></div>
<hr>

<h1>Module eipmi_session</h1>
<ul class="index"><li><a href="#description">Description</a></li><li><a href="#types">Data Types</a></li><li><a href="#index">Function Index</a></li><li><a href="#functions">Function Details</a></li></ul>
   A server providing session management for IPMI over lan channels.

<p><b>Behaviours:</b> <a href="gen_server.html"><tt>gen_server</tt></a>.</p>

<h2><a name="description">Description</a></h2><p>
   A server providing session management for IPMI over lan channels. The
   session will be established as soon as the server gets started. An
   established session will be closed when the server terminates. The user
   can close the session using <a href="#stop-1"><code>stop/1</code></a>.</p>
  
   <p>Synchronous requests can be issued over this session at any given time using
   <a href="#rpc-3"><code>rpc/3</code></a>. When the session is not yet established requests will be
   queued and issued as soon as the far end (BMC) is ready. Request timeouts
   can be configured on state machine startup using the <code>timeout</code> property
   of the <code>Options</code> field.</p>
  
   <p>A session may be shared between mutliple processes. While the requests of   
one process will be synchronous and thus ordered, requests from different   
processes will not block each other. However, it should be mentioned that   
a BMC is allowed to discard packets with a sequence number difference of 8.   
Since the session does not (yet) provide any kind of flow control it is the   
responsibility of the rpc-ing processes to care for the total number of   
concurrent RPCs or to live with error/timeout returns.</p>
  
   The server will handle the low level RMCP and IPMI protocol regarding
   encoding and decoding of messages, as well as correct packet
   acknowledgement, sequence number handling and session opening/closing.
   A session will use the modules <a href="eipmi_request.html"><code>eipmi_request</code></a> and
   <a href="eipmi_response.html"><code>eipmi_response</code></a> to encode and decode requests/responses. Therefore,
   there's no need to edit the session but extending these modules when
   support for new requests/responses is added.
  
<h2><a name="types">Data Types</a></h2>

<h3 class="typedecl"><a name="type-property">property()</a></h3>
<p><tt>property() = <a href="eipmi.html#type-option">eipmi:option()</a> | {auth_type, none | pwd | md5 | md2} | {auth_types, [none | pwd | md5 | md2]} | {challenge, binary()} | {completion, atom()} | {inbound_seq_nr, non_neg_integer()} | {login_status, [anonymous | null | non_null]} | {outbound_seq_nr, non_neg_integer()} | {rq_seq_nr, 0..64} | {session_id, non_neg_integer()}</tt></p>


<h3 class="typedecl"><a name="type-property_name">property_name()</a></h3>
<p><tt>property_name() = <a href="eipmi.html#type-option_name">eipmi:option_name()</a> | auth_type | auth_types | challenge | completion | inbound_seq_nr | login_status | outbound_seq_nr | rq_seq_nr | session_id</tt></p>


<h2><a name="index">Function Index</a></h2>
<table width="100%" border="1" cellspacing="0" cellpadding="2" summary="function index"><tr><td valign="top"><a href="#rpc-3">rpc/3</a></td><td>
  Send a synchronous IPMI RPC over this session.</td></tr>
<tr><td valign="top"><a href="#start_link-3">start_link/3</a></td><td>
  Starts a session server which in turn will occupy a free UDP socket.</td></tr>
<tr><td valign="top"><a href="#stop-1">stop/1</a></td><td>
  Stop the server, close the session.</td></tr>
</table>

<h2><a name="functions">Function Details</a></h2>

<h3 class="function"><a name="rpc-3">rpc/3</a></h3>
<div class="spec">
<p><tt>rpc(Pid::pid(), Request::<a href="eipmi.html#type-request">eipmi:request()</a>, Properties::<a href="proplists.html#type-proplist">proplists:proplist()</a>) -&gt; {ok, <a href="proplists.html#type-proplist">proplists:proplist()</a>} | {error, term()}</tt><br></p>
</div><p>
  Send a synchronous IPMI RPC over this session. If the session is not yet
  established the request will be queued.</p>

<h3 class="function"><a name="start_link-3">start_link/3</a></h3>
<div class="spec">
<p><tt>start_link(Session::<a href="eipmi.html#type-session">eipmi:session()</a>, IPAddress::<a href="inet.html#type-ip_address">inet:ip_address()</a> | <a href="inet.html#type-hostname">inet:hostname()</a>, Options::[<a href="#type-property">property()</a>]) -&gt; {ok, pid()} | {error, term()}</tt><br></p>
</div><p>
  Starts a session server which in turn will occupy a free UDP socket. The
  provided IP address and network port will be used to send requests. This
  means that the target for this session server is static and configured on
  startup. This will also setup a session by sending the necessary IPMI
  protocol messages. All requests received before the session is activated will
  be queued and sent as soon as the session is established.</p>

<h3 class="function"><a name="stop-1">stop/1</a></h3>
<div class="spec">
<p><tt>stop(Pid::pid()) -&gt; ok</tt><br></p>
</div><p>
  Stop the server, close the session.</p>
<hr>

<div class="navbar"><a name="#navbar_bottom"></a><table width="100%" border="0" cellspacing="0" cellpadding="2" summary="navigation bar"><tr><td><a href="overview-summary.html" target="overviewFrame">Overview</a></td><td><a href="http://www.erlang.org/"><img src="erlang.png" align="right" border="0" alt="erlang logo"></a></td></tr></table></div>
<p><i>Generated by EDoc, Nov 22 2012, 16:29:10.</i></p>
</body>
</html>
