@title EIPMI - A native Erlang IMPI library
@copyright 2012 Lindenbaum GmbH

@doc

== EIPMI ==

EIPMI is a native Erlang/OTP library application for RMCP/IPMI 1.5. The goal is
to implement the remote console part of the IPMI LAN interface, as specified
<a href="http://www.intel.com/design/servers/ipmi/spec.htm">here</a>. We would like to
provide a low threshold for learning and using EIPMI, aiming to make it fit well
with other Erlang/OTP concepts and solutions.

=== Initial planned features ===

<li> Simple API and user work-flow</li>
<li> Extensible design, open for contributions</li>
<li> RMCP presence ping/pong</li>
<li> Session initiation and activation</li>
<li> Some basic IPMI queries</li>
<li> Support for LAN alerts (events)</li>

We really want to provide a simple enough basic implementation, that is open
for extension, and not going for a complete coverage of the specification right
away - that should be added by the community as the needs appear.

=== Contributing ===

If you whish to contribute fixes or enhancements, please make your code look
nice, for example using the Emacs Erlang-mode, formatting your code before
committing. Also, you should always write proper <code>edoc</code> module documentation.
When writing documentation, please try to keep the tone simple and on a higher
abstraction level, so that users may understand the concepts without having to
know too much of the standard.

The modules <code>eipmi_request</code> and <code>eipmi_response</code> are a starting point for
developers that want add support for not yet implemented request/response pairs.
To add support for a new request the encoding of the corresponding IPMI data
part needs to be added to the <code>eipmi_request</code> module. To add support for a new
response the decoding of the corresponding IPMI data part needs to be added to
the <code>eipmi_response</code> module. As soon as encoding and decoding is implemented the
command is ready to be issued using <code>eipmi:raw/4</code>. For features that need to
combine multiple requests (e.g. reading the FRU) it would be even more nice to
add a corresponding frontend API function to the <code>eipmi</code> module.

=== Documentation ===

The following sections will give a brief description of the EIPMI features as
well as some usage examples for developers integrating the application into
their project. Additional information can be found in the projects EDoc
documentation located <a href="http://lindenbaum.github.com/eipmi/">here</a>.

=== Sessions &amp; Authentication ===

EIPMI does all the necessary session handling for the user as soon as a session
is requested using <code>eipmi:open/1</code> or <code>eipmi:open/2</code>. However, according to the
capabilities of the target BMC the user eventually has to pass in user and
password credentials using the <code>Options</code> argument of <code>eipmi:open/2</code>.

All authentication mechanism mentioned in the specification are supported,
including <em>anonymous</em>, <em>null user</em> and <em>non-null user</em>. Additionally, all
digester algorithms proposed by the specification are supported.

In case the target BMC only supports <em>non-null</em> users the options <code>user</code> and
<code>password</code> need to be passed to a call to <code>eipmi:open/2</code>. In case <em>null users</em>
are configured on the BMC only the <code>password</code> option will be required. If the
BMC supports <em>anonymous</em> logins no options need to be set.

A session may be shared between mutliple processes. While the requests of one
process will be synchronous and thus ordered, requests from different processes
will not block each other. However, flow control is performed over all requests
of a session. If a maximum of 64 pending requests is reached new requests will
be queued and sent as pending requests get completed.

=== Building ===

If you are using <a href="http://github.com/basho/rebar">rebar</a> to build your project
and want to use EIPMI just specify it as a dependency in your <code>rebar.config</code>
(please note that the below link will change in the future as soon as EIPMI gets
released for the first time).

```
{deps,
 [{eipmi, "1.0.0", {git, "https://github.com/lindenbaum/eipmi.git"}}]}.
'''

=== Usage ===

IPMI device discovery usually starts with a PING message to the target host:

```
case eipmi:ping("10.1.31.11") of
     pong ->
          ipmi_supported;
     pang ->
          ipmi_not_supported
end,
'''

After successful device discovery an actual session can be opened. This example
will open a session, read the FRU with id 253 and close the session again.

```
{ok, Session} = eipmi:open("10.1.31.11"),
{ok, FruInfo} = eipmi:read_fru(Session, 253),
BoardArea = proplists:get_value(board_area, FruInfo),
Name = proplists:get_value(name, BoardArea),
Serial = proplists:get_value(serial_number, BoardArea),
error_logger:info_msg("Board ~s has serial number ~s.~n", [Name, Serial]),
eipmi:close(Session),
'''

EIPMI also allows to send <em>raw</em> requests over a session. However, raw does not
mean that binary data can be sent directly. The corresponding request/response
encode/decode functionality must be present. The following snippet will issue
the <em>Set Session Privilege Level</em> command, trying to set the current session
privilege to <code>administrator</code>.

```
{ok, Response} = eipmi:raw(Session, 16#06, 16#3b, [{privilege, administrator}]),
NewPrivilege = proplists:get_value(privilege, Response),
error_logger:info_msg("New privilege level is ~p.~n", [NewPrivilege]),
'''

=== Command Support ===

The following commands are currently supported, e.g. can be sent as <code>raw</code>
request/response:

==== Get Device Id ====

Argument:
```
[]
'''

Return:
```
[{device_id, non_neg_integer()},
 {device_revision, non_neg_integer()},
 {operation, normal | progress},
 {firmware_version, string()},
 {ipmi_version, string()},
 {device_support, [chassis | bridge | event_generator | event_receiver | fru_inventory | sel | sdr | sensor]},
 {manufacturer_id, non_neg_integer()},
 {product_id, non_neg_integer()}]
'''

==== Cold Reset ====
Argument:
```
[]
'''

Return:
```
[]
'''

==== Warm Reset ====
Argument:
```
[]
'''

Return:
```
[]
'''

==== Get Self Test Results ====
Argument:
```
[]
'''

Return:
```
[{result,
  self_tests_passed |
  self_tests_not_implemented |
  {{corrupted_devices, [sel | sdr | fru | ipmb_signal_lines]},
   {inaccessible_devices, [sdr | fru | boot_firmware | optional_firmware]}} |
  {fatal_hardware_error, non_neg_integer()},
  {device_specific_error, non_neg_integer(), non_neg_integer()}}]
'''

==== Get Acpi Power State ====
Argument:
```
[]
'''

Return:
```
[{system,
  {s0_g0, working} |
  {s1, clocks_stopped} |
  {s2, clocks_stopped} |
  {s3, suspend_to_ram} |
  {s4, suspend_to_disk} |
  {s5_g2, soft_off} |
  {s4_s5, soft_off} |
  {g3, mechanical_off} |
  {s1_s2_s3, sleeping} |
  {g1, sleeping} |
  {s5, override} |
  legacy_on |
  legacy_off |
  unknown},
 {device, d0 | d1 | d2 | d3 | unknown}]
'''

==== Get Device GUID ====
Argument:
```
[]
'''

Return:
```
[{guid, string()}]
'''

==== Get System GUID ====
Argument:
```
[]
'''

Return:
```
[{guid, string()}]
'''

==== Get Channel Authentication Capabilities ====
Argument:
```
[{privilege, callback | user | operator | administrator}]
'''

Return:
```
[{auth_types, none | pwd | md2 | md5},
 {login_status, [null | non_null | anonymous]}]
'''

==== Get Session Challenge ====
Argument:
```
[{auth_type, none | pwd | md2 | md5},
 {user, string()}]
'''

Return:
```
[{session_id, non_neg_integer()},
 {challenge, binary()}]
'''

==== Activate Session ====
Argument:
```
[{auth_type, none | pwd | md2 | md5},
 {privilege, callback | user | operator | administrator},
 {challenge, binary()},
 {initial_outbound_seq_nr, non_neg_integer()}]
'''

Return:
```
[{session_id, non_neg_integer()},
 {inbound_seq_nr, non_neg_integer()},
 {auth_type, none | pwd | md2 | md5},
 {privilege, callback | user | operator | administrator}]
'''

==== Set Session Privilege Level ====
Argument:
```
[{privilege, callback | user | operator | administrator}]
'''

Return:
```
[{privilege, callback | user | operator | administrator}]
'''

==== Close Session ====
Argument:
```
[{session_id, non_neg_integer()}]
'''

Return:
```
[]
'''

==== Get FRU Inventory Area Info ====
Argument:
```
[{fru_id, 0..254}]
'''

Return:
```
[{area_size, non_neg_integer()},
 {access, by_words | by_bytes}]
'''

==== Read FRU Data ====
Argument:
```
[{fru_id, 0..254},
 {offset, non_neg_integer()},
 {count, 1..255}]
'''

Return:
```
[{count, 1..255},
 {data, binary()}]
'''

==== Get SEL Info ====
Argument:
```
[]
'''

Return:
```
[{version, string()},
 {entries, non_neg_integer()},
 {free_space, non_neg_integer()},
 {most_recent_addition, non_neg_integer()},
 {most_recent_erase, non_neg_integer()},
 {overflow, boolean()},
 {operations, [delete | partial_add | reserve | get_allocation_info]}]
'''

==== Reserve SEL ====
Argument:
```
[]
'''

Return:
```
[{reservation_id, non_neg_integer()}]
'''

==== Get SEL Entry ====
Argument:
```
[{record_id, non_neg_integer()}]
'''

Return:
```
[{next_record_id, non_neg_integer()},
 {data, binary()}]
'''

==== Clear SEL ====
Argument:
```
[{reservation_id, non_neg_integer()},
 {initiate, boolean()} (optional)]
'''

Return:
```
[{progress, completed | in_progress}]
'''

==== Get SDR Repository Info ====
Argument:
```
[]
'''

Return:
```
[{version, string()},
 {entries, non_neg_integer()},
 {free_space, non_neg_integer()},
 {most_recent_addition, non_neg_integer()},
 {most_recent_erase, non_neg_integer()},
 {overflow, boolean()},
 {operations, [delete | partial_add | reserve | get_allocation_info]}]
'''

==== Reserve SDR Repository ====
Argument:
```
[]
'''

Return:
```
[{reservation_id, non_neg_integer()}]
'''

==== Get SDR ====
Argument:
```
[{reservation_id, non_neg_integer()}, (optional)
 {record_id, non_neg_integer()},
 {offset, non_neg_integer()}, (optional)
 {count, 1..255} (optional)]
'''

Return:
```
[{next_record_id, non_neg_integer()},
 {data, binary()}]
'''

==== Get IP/UDP/RMCP Statistics ====
Argument:
```
[{clear_statistics, boolean()} (optional)]
'''

Return:
```
[{ip_packets_received, non_neg_integer()},
 {ip_header_errors, non_neg_integer()},
 {ip_address_errors, non_neg_integer()},
 {ip_fragmented_packets_received, non_neg_integer()},
 {ip_packets_transmitted, non_neg_integer()},
 {udp_packets_received, non_neg_integer()},
 {udp_proxy_packets_received, non_neg_integer()},
 {udp_proxy_packets_dropped, non_neg_integer()},
 {rmcp_packets_received, non_neg_integer()}]
'''

==== Get LAN Configuration Parameters ====
Argument:
```
[{parameter, 0..255},
 {set, 0..255}, (optional)
 {block, 0..255} (optional)]
'''

Returns:
```
[{data, binary()}]
'''
<script>
// Jump directly to a referenced url given in trailing '[]:...'-notation
function goto(tag) { parent.document.location.href = url(tag); }
function url(tag) { var o=document.getElementById(tag); return o ? o.href : '#'+tag; }
</script>
